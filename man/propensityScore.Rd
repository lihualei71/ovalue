% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic-ps.R
\name{propensityScore}
\alias{propensityScore}
\title{Propensity Score Estimation}
\usage{
propensityScore(
  T = NULL,
  X = NULL,
  formula = NULL,
  data = NULL,
  nfolds = 1,
  foldsizes = NULL,
  foldid = NULL,
  algo = c("gbm", "rf", "gam", "lasso", "logistic"),
  ...
)
}
\arguments{
\item{T}{logical vector or factor/vector encoded by 0 and 1. Treatment assignment}

\item{X}{matrix or data.frame. Covariate}

\item{formula}{formula object. See Details}

\item{data}{data.frame. See Details}

\item{nfolds}{positive integer. Number of folds for cross fitting. See Details}

\item{foldsizes}{vector of positive integers. See Details}

\item{foldid}{list of vectors. See Details}

\item{algo}{vector of strings or functions. See Details}

\item{...}{Other arguments passed into \code{algo}}
}
\value{
A vector of propensity scores
}
\description{
\code{propensityScore} is a generic wrapper to estimate propensity scores for binary treatment with or without cross-fitting.
}
\details{
\code{propensityScore} estimates propensity score for binary treatment. It supports both in-sample fitting, where the model is used on the whole dataset and the propensity scores are fitting based on the model, and cross fitting, where the data is splitted into \code{nfolds} subsets and the propensity score for each subset is estimated based on the model fitted on other subsets. In practice, it is crucial to apply cross fitting because the in-sample fits may be pulled towards 0 and 1 because of the non-negligible finite-sample errors.

Users can avoid using cross fitting by \code{nfolds = 1}.  Otherwise users can specify the splitting scheme by one of the following argument:
\itemize{
\item \code{foldid}: a list of indices that form a partition of 1:n. If \code{foldid} is not NULL, then the arguments \code{nfolds} and \code{foldsizes} will be ignored,
\item \code{foldsizes}: a vector of positive integers that sum up to n. \code{propensityScore} will generate a uniformly random partition with sizes given by the elements of \code{foldsizes},
\item \code{nfolds}: a positive integer. \code{propensityScore} will generate a uniformly random partition with \code{nfolds} folds and equal sizes (up to 1) within each fold.
}

\code{propensityScore} supports a bunch of algorithms and provides a flexible framework that allows for arbitrary classifiers. The algorithm to use is specified by the argument \code{algo}. \code{algo} can be a valid string, including
\itemize{
\item "logistic" for logistic regression,
\item "lasso" for L1-penalized logistic regression,
\item "gam" for generalized additive model,
\item "gbm" for generalized boosting machine,
\item "rf" for random forest,
}

or a function object whose inputs must include
\itemize{
\item "T" for treatment vector, must be a logical vector or a factor/vector encoded by 0 and 1,
\item "X" for covariates, must be a vector/matrix/data.frame,
\item "trainid" for the index of training samples, must be a logical vector or a vector of integers.
\item "testid" for the index of testing samples, must be a logical vector or a vector of integers. "testid" is allowed to overlap with "trainid".
The default setting is \code{algo = "gbm"}.
}

\code{propensityScore} supports two types of data inputs: (1) \code{T} and \code{X} or (2) \code{formula} and \code{data}. One of the pair has to be specified.
}
\examples{
\donttest{# Generate data from a logistic model
set.seed(1)
n <- 1000
p <- 50
X <- matrix(stats::rnorm(n * p), n, p)
beta <- rep(1 / sqrt(p), p)
probs <- 1 / (1 + exp(-X \%*\% beta))
T <- stats::runif(n) <= probs
data <- data.frame(T = T, X)

# Calculate propensity scores using GBM with 5-folds cross fitting
propensityScore(T, X, algo = "gbm", nfolds = 5)

# Calculate propensity scores using GBM without cross fitting
propensityScore(T, X, algo = "gbm", nfolds = 1)
}

}
